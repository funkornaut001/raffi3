//SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "../lib/forge-std/src/Test.sol";
import "../src/ManagerERC20.sol";
import "../lib/solmate/src/test/utils/mocks/MockERC721.sol";
import "../lib/solmate/src/test/utils/mocks/MockERC20.sol";

abstract contract HelperRaffleEnded is Test {
    address alice = address(0x1337);
    address bob = address(0x133702);
    address charlie = address(0x133703);
    
    ManagerERC20 public managerERC20;
    // All the different status raffles can have
    enum STATUS {
        CREATED, // the operator creates the raffle
        ACCEPTED, // the seller stakes the nft for the raffle
        EARLY_CASHOUT, // the seller wants to cashout early
        CANCELLED, // the operator cancels the raffle and transfer the remaining funds after 30 days passes
        CLOSING_REQUESTED, // the operator sets a winner
        ENDED, // the raffle is finished, and NFT and funds were transferred
        CANCEL_REQUESTED // operator asks to cancel the raffle. Players has 30 days to ask for a refund
    }

    struct TestRaffleStruct {
        STATUS status; // status of the raffle. Can be created, accepted, ended, etc
        PaymentInfo paymentInfo;
        uint256 maxEntries; // maximum number of entries, aka total ticket supply
        // TODO: NFT struct w/address & Id?
        address collateralAddress; // address of the NFT
        uint256 collateralId; // NFT id of the collateral NFT
        address winner; // address of the winner of the raffle. Default to seller if no tickets bought
        uint256 randomNumber; // normalized (0-Entries array size) random number generated by the VRF
        address seller; // address of the seller of the NFT
        // TODO: make platform percentage a constant variable
        uint256 platformPercentage; // percentage of the funds raised that goes to the platform
        uint256 entriesLength; // the length of the entries array is saved here
        uint256 expiryTimeStamp; // end date of the raffle
        bool randomNumberAvailable; //random number returned from VRF
    }

    // The main structure is an array of raffles
    TestRaffleStruct[] public tRaffles;

    struct PaymentInfo {
        bool isNativeToken;
        address paymentToken;
        uint256 pricePerTicketInWeis;
        uint256 amountRaised;
    }

    struct PriceStructure {
        uint256 id;
        uint256 numEntries;
        uint256 price;
    }

    event RaffleCreated(
        uint256 indexed raffleId,
        address indexed nftAddress,
        uint256 indexed nftId
    );

    MockERC721 nft;

    function createRaffleEnded() internal {
        uint256 maxEntries = 10;
        ManagerERC20.PaymentInfo memory paymentInfo = ManagerERC20.PaymentInfo({
            isNativeToken: true,
            paymentToken: address(0),
            pricePerTicketInWeis: 1,
            amountRaised: 0
        });
        address collateralAddress = address(nft);
        uint256 collateralId = 1;
        ManagerERC20.PriceStructure[]
            memory prices = new ManagerERC20.PriceStructure[](1);
        prices[0] = ManagerERC20.PriceStructure({
            id: 0,
            numEntries: 10,
            price: 1
        });
        uint256 entriesLength = 0;
        uint256 expiryTimeStamp = block.timestamp + 10 minutes;

        vm.startPrank(address(alice));

        managerERC20.createRaffle(
            maxEntries,
            paymentInfo,
            collateralAddress,
            collateralId,
            prices,
            expiryTimeStamp
        );

        // raffles.push(raffle);
        vm.stopPrank();
        // Push the new raffle instance into testRaffles array

        TestRaffleStruct memory raffle_test = TestRaffleStruct({
            status: STATUS.CLOSING_REQUESTED,
            paymentInfo: PaymentInfo({
                isNativeToken: true,
                paymentToken: address(0),
                pricePerTicketInWeis: 1,
                amountRaised: 0
            }),
            maxEntries: maxEntries,
            collateralAddress: collateralAddress,
            collateralId: collateralId,
            winner: alice,
            randomNumber: 1, // set an initial value for randomNumber
            seller: alice,
            platformPercentage: 0, // set an initial value for platformPercentage
            entriesLength: entriesLength,
            expiryTimeStamp: expiryTimeStamp,
            randomNumberAvailable: true // set an initial value for randomNumberAvailable
        });

        tRaffles.push(raffle_test);
    }
}
