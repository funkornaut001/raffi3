// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";
import "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";

contract RaffiGas is
    AccessControl,
    ReentrancyGuard,
    VRFConsumerBaseV2,
    ConfirmedOwner,
    AutomationCompatibleInterface
{
    using SafeERC20 for IERC20;
    /////////////////
    // Events  //////
    /////////////////

    event RaffleCreated(
        uint256 indexed raffleId,
        address indexed nftAddress,
        uint256 indexed nftId
    );

    event RaffleStarted(uint256 indexed raffleId, address indexed seller);

    event RaffleEnded(
        uint256 indexed raffleId,
        address indexed winner,
        uint256 amountRaised,
        uint256 randomNumber
    );

    event EntrySold(
        uint256 indexed raffleId,
        address indexed buyer,
        uint256 currentSize
    );

    event FreeEntry(
        uint256 indexed raffleId,
        address[] buyer,
        uint256 amount,
        uint256 currentSize
    );

    event RaffleCancelled(uint256 indexed raffleId, uint256 amountRaised);

    event SetWinnerTriggered(uint256 indexed raffleId, uint256 amountRaised);

    event RequestSent(uint256 requestId, uint32 numWords);

    event RequestFulfilled(
        uint256 requestId,
        uint256[] randomWords,
        uint256 raffleId
    );

    //////////////
    // Structs  //
    //////////////

    struct ClaimStruct {
        uint256 numEntriesPerUser;
        uint256 amountSpentInWeis;
        bool claimed;
    }

    struct PaymentInfo {
        bool isNativeToken;
        address paymentToken;
        uint256 pricePerTicketInWeis;
        uint256 amountRaised;
    }

    // Main raffle data struct
    struct RaffleStruct {
        STATUS status; // status of the raffle. Can be created, accepted, ended, etc
        PaymentInfo paymentInfo;
        uint256 maxEntries; // maximum number of entries, aka total ticket supply
        // TODO: NFT struct w/address & Id?
        address collateralAddress; // address of the NFT
        uint256 collateralId; // NFT id of the collateral NFT
        address winner; // address of the winner of the raffle. Default to seller if no tickets bought
        uint256 randomNumber; // normalized (0-Entries array size) random number generated by the VRF
        address seller; // address of the seller of the NFT
        uint256 entriesLength; // the length of the entries array is saved here
        uint256 expiryTimeStamp; // end date of the raffle
        bool randomNumberAvailable; //random number returned from VRF
    }

    // The main structure is an array of raffles
    RaffleStruct[] public raffles;

    struct RaffleInfo {
        uint256 id;
        uint256 size;
    }

    struct RequestStatus {
        bool fulfilled; // whether the request has been successfully fulfilled
        bool exists; // whether a requestId exists
        uint256[] randomWords;
    }

    struct EntriesBought {
        uint256 currentEntriesLength;
        address player;
    }

    //////////////
    // Mappings //
    //////////////
    mapping(uint256 => RequestStatus)
        public s_requests; /* requestId --> requestStatus */

    // map the requestId created by chainlink with the raffle info passed as param when calling requestRandomWords()
    mapping(uint256 => RaffleInfo) public chainlinkRaffleInfo;

    // every raffle has a sorted array of EntriesBought. Each element is created when calling
    // either buyEntry or giveBatchEntriesForFree
    mapping(uint256 => EntriesBought[]) public entriesList;

    mapping(bytes32 => ClaimStruct) public claimsData;

    mapping(uint256 => mapping(address => uint256))
        public raffleCumulativeEntries;

    mapping(address => bool) public tokenApprovedList;

    // All the different status raffles can have
    enum STATUS {
        CREATED, // the operator creates the raffle
        ACCEPTED, // the seller stakes the nft for the raffle
        EARLY_CASHOUT, // the seller wants to cashout early
        CANCELLED, // the operator cancels the raffle and transfer the remaining funds after 30 days passes
        CLOSING_REQUESTED, // the operator sets a winner
        ENDED, // the raffle is finished, and NFT and funds were transferred
        CANCEL_REQUESTED // operator asks to cancel the raffle. Players has 30 days to ask for a refund
    }

    // The operator role is operated by a backend application
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR");

    address payable public immutable i_destinationWallet;

    /**VRF Variables */

    // past requests Id.
    uint256[] public requestIds;
    uint256 public lastRequestId;

    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;

    // Your VRF V2 coordinator subscription ID.
    uint64 private immutable i_subscriptionId;

    bytes32 private immutable i_gasLane;
    uint32 private immutable i_callbackGasLimit;
    uint16 private constant REQUEST_CONFIRMATIONS = 5;
    uint8 private constant NUM_WORDS = 1;

    // Global Variables
    uint16 private constant PLATFORM_PERCENTAGE = 500; // 5%

    constructor(
        uint64 subscriptionId,
        bytes32 gasLane,
        uint32 callbackGasLimit,
        address vrfCoordinatorV2,
        address payable destinationWallet
    )
        //address payable destinationWallet
        VRFConsumerBaseV2(vrfCoordinatorV2)
        ConfirmedOwner(msg.sender)
    {
        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);
        i_subscriptionId = subscriptionId;
        i_gasLane = gasLane;
        i_callbackGasLimit = callbackGasLimit;
        i_destinationWallet = destinationWallet;

        //TODO get ride of hardcode

        _setupRole(
            OPERATOR_ROLE,
            // address(0x11E7Fa3Bc863bceD1F1eC85B6EdC9b91FdD581CF)
            address(0x9768818565ED5968fAACC6F66ca02CBf2785dB84)
        );
        _setupRole(
            DEFAULT_ADMIN_ROLE,
            // address(0x11E7Fa3Bc863bceD1F1eC85B6EdC9b91FdD581CF)
            address(0x9768818565ED5968fAACC6F66ca02CBf2785dB84)
        );
    }

    //////////////////////////
    ///// VRFv2 functions ////
    //////////////////////////

    // this function is called be performUpkeep once a raffle has met the conditions for ending.
    // It will request a random number from the VRF and save the raffleId and the number of entries in the raffle in a map.
    // If a request is successful, the callback function, fulfillRandomWords will be called.
    /// @param _id is the raffleID
    /// @param _entriesSize is the number of entries in the raffle
    /// @return requestId is the requestId generated by chainlink
    function requestRandomWords(
        uint256 _id,
        uint256 _entriesSize
    ) internal returns (uint256 requestId) {
        // Will revert if subscription is not set and funded.
        requestId = i_vrfCoordinator.requestRandomWords(
            i_gasLane,
            i_subscriptionId,
            REQUEST_CONFIRMATIONS,
            i_callbackGasLimit,
            NUM_WORDS
        );
        s_requests[requestId] = RequestStatus({
            randomWords: new uint256[](0),
            exists: true,
            fulfilled: false
        });

        requestIds.push(requestId);
        lastRequestId = requestId;

        // result is the requestId generated by chainlink. It is saved in a map linked to the param id
        chainlinkRaffleInfo[requestId] = RaffleInfo({
            id: _id,
            size: _entriesSize
        });
        emit RequestSent(requestId, NUM_WORDS);
        return requestId;
    }

    // This is the callback function called by the VRF when the random number is ready.
    // It will emit an event with the original raffleId and the random number.
    /// @param _requestId is the requestId generated by chainlink
    /// @param _randomWords is the random number generated by the VRF
    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {
        RaffleStruct storage raffle = raffles[
            chainlinkRaffleInfo[_requestId].id
        ];
        raffle.randomNumber =
            (_randomWords[0] % chainlinkRaffleInfo[_requestId].size) +
            1;
        raffle.randomNumberAvailable = true;

        emit RequestFulfilled(
            _requestId,
            _randomWords,
            chainlinkRaffleInfo[_requestId].id
        );

        transferNFTAndFunds(chainlinkRaffleInfo[_requestId].id);
    }

    /////////////////////////
    //// Automation /////////
    /////////////////////////

    /**
     * @dev This is the function that the Chainlink Keeper nodes call
     * they look for `upkeepNeeded` to return True.
     * the following should be true for this to return true:
     * 1. The raffle has been accepted.
     * 2. The raffle has sold out or the time has passed.
     * 3. The raffle has participants (entries bought).
     * 4. Implicity, your subscription is funded with LINK.
     */
    function checkUpkeep(
        bytes memory /* checkData */
    )
        public
        view
        override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        for (uint256 i = 0; i < raffles.length; i++) {
            RaffleStruct storage raffle = raffles[i];
            bool isReady = (raffle.expiryTimeStamp < block.timestamp ||
                raffle.entriesLength == raffle.maxEntries);
            upkeepNeeded = (raffle.status == STATUS.ACCEPTED && isReady);
            if (upkeepNeeded) {
                performData = abi.encode(i);
                break;
            }
        }
    }

    /**
     * @dev Once `checkUpkeep` is returning `true`, this function is called
     * and it kicks off a Chainlink VRFv2 call to get a random number.
     */
    function performUpkeep(bytes calldata performData) external override {
        uint256 raffleId = abi.decode(performData, (uint256));
        RaffleStruct storage raffle = raffles[raffleId];

        (bool upkeepNeeded, ) = checkUpkeep("");
        require(upkeepNeeded, "Upkeep not needed");
        require(raffleId < raffles.length, "Invalid raffleId");
        require(raffle.status == STATUS.ACCEPTED, "Raffle in wrong status");
        //require(raffle.entriesLength > 0, "Raffle has no entries");
        require(
            raffle.expiryTimeStamp < block.timestamp ||
                raffle.entriesLength == raffle.maxEntries,
            "Raffle not expired or sold out yet"
        );

        raffle.status = STATUS.CLOSING_REQUESTED;
        requestRandomWords(raffleId, raffle.entriesLength);
        //might want to rename
        emit SetWinnerTriggered(raffleId, raffle.paymentInfo.amountRaised);
    }

    ////////////////////////
    /// Raffle Functions ///
    ////////////////////////
    // function to create a raffle
    /// @param _collateralAddress The address of the NFT of the raffle
    /// @param _collateralId The id of the NFT (ERC721)
    /// @return raffleId
    function createRaffle(
        uint256 _maxEntries,
        PaymentInfo calldata _paymentInfo,
        address _collateralAddress,
        uint256 _collateralId,
        //PriceStructure[] calldata _prices,
        uint256 _expiryTimeStamp
    ) external returns (uint256) {
        // uint256 _minimumFundsInWeis = 1;
        address _raffleCreator = msg.sender;

        // checks the tokenApprovedList for payment token
        if (_paymentInfo.isNativeToken == false) {
            require(
                isTokenApproved(_paymentInfo.paymentToken),
                "ERC20 payment token not approved"
            );
        }
        require(_collateralAddress != address(0), "NFT is null");
        require(_collateralId != 0, "NFT id is null");
        require(_maxEntries > 0, "Max entries is needs to be greater than 0");
        require(
            _expiryTimeStamp > block.timestamp,
            "Expiry time is in the past"
        );
        require(
            _paymentInfo.pricePerTicketInWeis > 0,
            "Price per ticket needs to be greater than 0"
        );

        /* instantiate the raffle struct and push it to the raffles array
         the winner defaults to the raffle creator if no one buys a ticket */
        RaffleStruct memory raffle = RaffleStruct({
            status: STATUS.CREATED,
            paymentInfo: PaymentInfo({
                isNativeToken: _paymentInfo.isNativeToken,
                paymentToken: _paymentInfo.paymentToken,
                pricePerTicketInWeis: _paymentInfo.pricePerTicketInWeis,
                amountRaised: 0
            }),
            maxEntries: _maxEntries,
            collateralAddress: _collateralAddress,
            collateralId: _collateralId,
            winner: _raffleCreator,
            randomNumber: 0,
            seller: _raffleCreator,
            entriesLength: 0,
            expiryTimeStamp: _expiryTimeStamp,
            randomNumberAvailable: false
        });

        raffles.push(raffle);


        uint256 raffleID = raffles.length - 1;
   
        emit RaffleCreated(raffleID, _collateralAddress, _collateralId);

        stakeNFT(raffleID);
        return raffleID;
    }

    // function for the creator of the raffle to stake the NFT
    // the NFT is transferred to the contract and the status of the raffle is set to ACCEPTED
    /// @param _raffleId Id of the raffle
    function stakeNFT(uint256 _raffleId) internal {
        RaffleStruct storage raffle = raffles[_raffleId];

        // ensure the raffle is in the CREATED state. This should be the next state after the raffle is created
        require(raffle.status == STATUS.CREATED, "Raffle not CREATED");

        IERC721 token = IERC721(raffle.collateralAddress);
        require(
            token.ownerOf(raffle.collateralId) == msg.sender,
            "NFT is not owned by caller"
        );

        raffle.status = STATUS.ACCEPTED;
        token.transferFrom(msg.sender, address(this), raffle.collateralId); // transfer the token to the contract

        emit RaffleStarted(_raffleId, msg.sender);
    }

    /// function to buy a ticket for a raffle. The user can buy multiple tickets at once
    /// As the method is payable, in msg.value there will be the amount paid by the user if the paymentToken is the native blockchian token.
    /// If the payment token is an erc20 the totalDue will be #oftickets * price of tickets.
    /// @param _raffleId: id of the raffle
    /// @param _numberOfTickets: number of tickets the user wants to buy
    function buyEntry(
        uint256 _raffleId,
        uint256 _numberOfTickets
    ) external payable nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];

        require(
            msg.sender != raffle.seller,
            "The seller cannot buy their own tickets"
        );
        require(msg.sender != address(0), "msg.sender is null");
        require(
            raffle.status == STATUS.ACCEPTED,
            "Raffle must be in ACCEPTED state"
        );
        require(raffle.expiryTimeStamp > block.timestamp, "Raffle has expired");
        require(
            raffle.entriesLength < raffle.maxEntries,
            "Raffle has reached max entries"
        );
        require(
            _numberOfTickets <= (raffle.maxEntries - raffle.entriesLength),
            "buying more than the maximum tickets"
        );

        // update raffle entry length
        raffle.entriesLength = raffle.entriesLength + _numberOfTickets;

        uint256 totalDue = (_numberOfTickets *
            raffle.paymentInfo.pricePerTicketInWeis);
        bytes32 hash = keccak256(abi.encode(msg.sender, _raffleId));

        //update claim data
        claimsData[hash].numEntriesPerUser += _numberOfTickets;
        claimsData[hash].amountSpentInWeis += totalDue;

        if (raffle.paymentInfo.isNativeToken) {
            require(
                msg.value == totalDue,
                "msg.value must be equal to the price * number of tickets"
            );
            raffle.paymentInfo.amountRaised += msg.value;
        } else {
            IERC20 paymentToken = IERC20(raffle.paymentInfo.paymentToken);
            require(
                paymentToken.allowance(msg.sender, address(this)) >= totalDue,
                "Not enough allowance provided for the payment token"
            );
            raffle.paymentInfo.amountRaised += totalDue;
            paymentToken.safeTransferFrom(msg.sender, address(this), totalDue);
        }

        EntriesBought memory entryBought = EntriesBought({
            player: msg.sender,
            currentEntriesLength: _numberOfTickets
        });
        entriesList[_raffleId].push(entryBought);

        emit EntrySold(_raffleId, msg.sender, _numberOfTickets);
    }

    // modifier for transferNFTAndFunds. It will check that the caller is the owner or the seller
    /// @param _raffleId is the raffleId
    modifier onlyTrustedCaller(uint256 _raffleId) {
        RaffleStruct storage raffle = raffles[_raffleId];
        require(
            msg.sender == owner() || msg.sender == raffle.seller, // Add other trusted parties if necessary
            "Caller not authorized"
        );
        _;
    }

    /**
     * This function will transfer the NFT to the winner and the funds to the seller & platform.
     * Only the raffle creator or the platform owner can call this function.
     * @param _raffleId Id of the raffle
     */
    function transferNFTAndFunds(uint256 _raffleId) internal nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];
        // Check that the random number is available and the raffle is in the correct state
        require(
            raffle.randomNumberAvailable &&
                raffle.status == STATUS.CLOSING_REQUESTED,
            "Raffle in wrong status or random number not available"
        );
        raffle.winner = (raffle.paymentInfo.amountRaised == 0)
            ? raffle.seller
            : getWinnerAddressFromRandom(_raffleId, raffle.randomNumber);

        raffle.status = STATUS.ENDED;
        raffle.randomNumberAvailable = false;

        IERC721(raffle.collateralAddress).transferFrom(
            address(this),
            raffle.winner,
            raffle.collateralId
        );

        uint256 amountForPlatform = (raffle.paymentInfo.amountRaised *
            PLATFORM_PERCENTAGE) / 10000;
        uint256 amountForSeller = raffle.paymentInfo.amountRaised -
            amountForPlatform;

        if (raffle.paymentInfo.isNativeToken == false) {
            // transfer 95% to the seller
            IERC20(raffle.paymentInfo.paymentToken).safeTransfer(
                raffle.seller,
                amountForSeller
            );
            // transfer 5% to the platform
            IERC20(raffle.paymentInfo.paymentToken).safeTransfer(
                i_destinationWallet,
                amountForPlatform
            );
        } else {
            // transfer of native blockchain token
            // transfer 95% to the seller
            (bool sent, ) = raffle.seller.call{value: amountForSeller}("");
            require(sent, "Failed to send Ether to seller");

            // transfer 5% to the platform
            (bool sent2, ) = i_destinationWallet.call{value: amountForPlatform}(
                ""
            );
            require(sent2, "Failed to send Ether to platform");
        }



        emit RaffleEnded(
            _raffleId,
            raffle.winner,
            raffle.paymentInfo.amountRaised,
            raffle.randomNumber
        );
    }

    // The operator can add free entries to the raffle
    /// @param _raffleId Id of the raffle
    /// @param _freePlayers array of addresses corresponding to the wallet of the users that won a free entrie
    /// @dev only operator can make this call. Assigns a single entry per user, except if that user already reached the max limit of entries per user
    function giveBatchEntriesForFree(
        uint256 _raffleId,
        address[] memory _freePlayers
    ) external nonReentrant onlyRole(OPERATOR_ROLE) {
        require(
            raffles[_raffleId].status == STATUS.ACCEPTED,
            "Raffle is not in accepted"
        );

        uint256 freePlayersLength = _freePlayers.length;
        uint256 validPlayersCount = 0;

        for (uint256 i = 0; i < freePlayersLength; i++) {
            address entry = _freePlayers[i];
            EntriesBought memory entryBought = EntriesBought({
                player: entry,
                currentEntriesLength: 1
            });
            entriesList[_raffleId].push(entryBought);

            claimsData[keccak256(abi.encode(entry, _raffleId))]
                .numEntriesPerUser++; // needed?

            ++validPlayersCount;
        }

        raffles[_raffleId].entriesLength =
            raffles[_raffleId].entriesLength +
            validPlayersCount;

        emit FreeEntry(
            _raffleId,
            _freePlayers,
            freePlayersLength,
            raffles[_raffleId].entriesLength
        );
    }

    /////////////////////////////
    ////// Getter functions /////
    /////////////////////////////

    // getter function to check the balance of the contract of the paymentToken based on the raffleId
    /// @param _raffleId Id of the raffle
    /// @return balance of the contract
    function getBalance(uint256 _raffleId) public view returns (uint256) {
        RaffleStruct storage raffle = raffles[_raffleId];
        if (raffle.paymentInfo.isNativeToken == false) {
            return
                IERC20(raffle.paymentInfo.paymentToken).balanceOf(
                    address(this)
                );
        } else {
            return address(this).balance;
        }
    }

    /// @dev checks to see if the token is on the whitelist
    function isTokenApproved(address _token) public view returns (bool) {
        return tokenApprovedList[_token];
    }

    // helper unction to view the current status of the raffle
    /// @param _raffleId Id of the raffle
    /// @return status of the raffle
    function getRaffleStatus(uint256 _raffleId) public view returns (STATUS) {
        RaffleStruct storage raffle = raffles[_raffleId];
        return raffle.status;
    }

    // helper unction to get the status of the chainlink request
    /// @param _requestId Id of the request
    /// @return fulfilled status of the request
    /// @return randomWords random number generated by the VRF
    function getRequestStatus(
        uint256 _requestId
    ) external view returns (bool fulfilled, uint256[] memory randomWords) {
        require(s_requests[_requestId].exists, "request not found");
        RequestStatus memory request = s_requests[_requestId];
        return (request.fulfilled, request.randomWords);
    }

    // helper function to get the length of entriesList for a raffle
    /// @param _raffleId Id of the raffle
    /// @return length of the entriesList
    function getEntriesSize(uint256 _raffleId) public view returns (uint256) {
        return entriesList[_raffleId].length;
    }

    // helper function to get the raffle randomNumberAvailable bool for a raffle
    /// @param _raffleId Id of the raffle
    /// @return randomNumberAvailable bool
    function getRandomNumberAvailable(
        uint256 _raffleId
    ) public view returns (bool) {
        return raffles[_raffleId].randomNumberAvailable;
    }

    // helper function to get the raffle randomNumber for a raffle
    /// @param _raffleId Id of the raffle
    /// @return randomNumber
    function getRaffleRandomNumber(
        uint256 _raffleId
    ) public view returns (uint256) {
        return raffles[_raffleId].randomNumber;
    }

    // helper function to get the number of all the entries bought for a
    // particular raffle
    /// @param _raffleId Id of the raffle
    /// @return entriesLength length of entries
    function getNumberOfEntries(
        uint256 _raffleId
    ) public view returns (uint256) {
        RaffleStruct storage raffle = raffles[_raffleId];
        return raffle.entriesLength;
    }

    // helper function to get all of the raffle struct data
    // for a particular raffle Id
    /// @param _raffleId Id of the raffle
    function getRaffle(
        uint256 _raffleId
    )
        public
        view
        returns (
            STATUS,
            uint256,
            uint256,
            bool,
            address,
            uint256,
            address,
            uint256,
            uint256,
            address,
            uint256,
            uint256
        )
    {
        RaffleStruct storage raffle = raffles[_raffleId];
        return (
            raffle.status,
            raffle.paymentInfo.pricePerTicketInWeis,
            raffle.paymentInfo.amountRaised,
            raffle.paymentInfo.isNativeToken,
            raffle.collateralAddress,
            raffle.collateralId,
            raffle.seller,
            raffle.entriesLength,
            raffle.randomNumber,
            raffle.winner,
            raffle.expiryTimeStamp,
            raffle.maxEntries
        );
    }

    /// @dev returns the winner address from a random number
    /// @param _raffleId Id of the raffle
    /// @param _normalizedRandomNumber random number generated by the VRF normalized to the raffle entries
    function getWinnerAddressFromRandom(
        uint256 _raffleId,
        uint256 _normalizedRandomNumber
    ) internal view returns (address) {
        RaffleStruct storage raffle = raffles[_raffleId];
        EntriesBought[] storage entries = entriesList[_raffleId];

        uint256 cumulativeSum = 0;
        address winner = raffle.seller;

        for (uint256 i = 0; i < entries.length; i++) {
            if (entries[i].player == raffle.seller) {
                continue; // Skip the seller's entry
            }

            cumulativeSum += entries[i].currentEntriesLength;

            if (cumulativeSum >= _normalizedRandomNumber) {
                winner = entries[i].player;
                break;
            }
        }

        require(winner != address(0), "Winner not found");
        return winner;
    }

    // helper function to get the number of entries for a given wallet address
    /// @param _raffleId Id of the raffle
    /// @param _player address of the player
    /// @return number of entries for the player
    function getNumberOfEntriesForPlayer(
        uint256 _raffleId,
        address _player
    ) public view returns (uint256) {
        //RaffleStruct storage raffle = raffles[_raffleId];
        EntriesBought[] storage entries = entriesList[_raffleId];
        for (uint256 i = 0; i < entries.length; i++) {
            if (entries[i].player == _player) {
                return entries[i].currentEntriesLength;
            }
        }
        return 0;
    }

    /////////////////////////////
    ////// Helper functions /////
    /////////////////////////////

    /// @dev adds token to whitelist of approved tokens for ticket payment
    function addTokenToApproved(address _token) public onlyOwner {
        tokenApprovedList[_token] = true;
    }

    /// @dev removes token from whitelist of approved tokens for ticket payment
    function removeTokenFromApproved(address _token) public onlyOwner {
        tokenApprovedList[_token] = false;
    }

    // helper function for onlyOwner to extract the NFT from the contract
    // in the case of a failed raffle. This is to avoid the NFT being stuck in the contract
    // if the chainlink callback function does not exectute as expected
    /// @param _raffleId Id of the raffle
    function extractNFT(uint256 _raffleId) public onlyOwner nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];
        require(raffle.collateralId != 0, "Raffle collateralId is not set");
        require(
            raffle.collateralAddress != address(0),
            "Raffle collateralAddress is not set"
        );
        IERC721(raffle.collateralAddress).safeTransferFrom(
            address(this),
            owner(),
            raffle.collateralId
        );
    }

    // helper function for onlyOwner to extract the funds from the contract
    // in the case of a failed raffle. This is to avoid the funds being stuck in the contract
    // if the chainlink callback function does not exectute as expected
    /// @param _raffleId Id of the raffle
    function extractFunds(
        uint256 _raffleId
    ) public payable onlyOwner nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];
        require(raffle.collateralId != 0, "Raffle collateralId is not set");
        require(
            raffle.collateralAddress != address(0),
            "Raffle collateralAddress is not set"
        );

        payable(owner()).transfer(raffle.paymentInfo.amountRaised);
    }

    // function to set the winner of a raffle, kicks off VRF.
    /// @param _raffleId Id of the raffle
    /// might not need but will keep incause Automation goes down
    function setWinner(uint256 _raffleId) external onlyOwner nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];

        require(raffle.status == STATUS.ACCEPTED, "Raffle in wrong status");
        require(
            raffle.expiryTimeStamp < block.timestamp ||
                raffle.entriesLength == raffle.maxEntries,
            "Raffle not expired yet or not sold out"
        );

        raffle.status = STATUS.CLOSING_REQUESTED;

        requestRandomWords(_raffleId, raffle.entriesLength);
        // raffle.status = STATUS.CLOSING_REQUESTED;
        emit SetWinnerTriggered(_raffleId, raffle.paymentInfo.amountRaised);
    }

    /**
     * This function will transfer the NFT to the winner and the funds to the seller & platform.
     * Only the raffle creator or the platform owner can call this function.
     * @param _raffleId Id of the raffle
     */
    function transferNFTAndFundsEmergency(
        uint256 _raffleId,
        uint256 _normalizedRandomNumber
    ) external onlyOwner nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];
        // Check that the random number is available and the raffle is in the correct state
        require(
            raffle.randomNumberAvailable &&
                raffle.status == STATUS.CLOSING_REQUESTED,
            "Raffle in wrong status or random number not available"
        );
        raffle.winner = (raffle.paymentInfo.amountRaised == 0)
            ? raffle.seller
            : getWinnerAddressFromRandom(_raffleId, _normalizedRandomNumber);

        raffle.status = STATUS.ENDED;
        raffle.randomNumberAvailable = false;

        IERC721(raffle.collateralAddress).transferFrom(
            address(this),
            raffle.winner,
            raffle.collateralId
        );

        uint256 amountForPlatform = (raffle.paymentInfo.amountRaised *
            PLATFORM_PERCENTAGE) / 10000;
        uint256 amountForSeller = raffle.paymentInfo.amountRaised -
            amountForPlatform;

        if (raffle.paymentInfo.isNativeToken == false) {
            // transfer 95% to the seller
            IERC20(raffle.paymentInfo.paymentToken).safeTransfer(
                raffle.seller,
                amountForSeller
            );
            // transfer 5% to the platform
            IERC20(raffle.paymentInfo.paymentToken).safeTransfer(
                i_destinationWallet,
                amountForPlatform
            );
        } else {
            (bool sent, ) = raffle.seller.call{value: amountForSeller}("");
            require(sent, "Failed to send Ether to seller");

            // transfer 5% to the platform
            (bool sent2, ) = i_destinationWallet.call{value: amountForPlatform}(
                ""
            );
            require(sent2, "Failed to send Ether to platform");
        }

        emit RaffleEnded(
            _raffleId,
            raffle.winner,
            raffle.paymentInfo.amountRaised,
            raffle.randomNumber
        );
    }

    // retry function to set the winner of a raffle. Only callable by the owner
    // or the seller. This is useful in case Chainlink VRF fails to generate a random number
    // and we need to retrigger the chainlink VRF
    /// @param _id is the raffleID
    /// @return requestId is the requestId generated by chainlink
    function requestRandomWordsRetryOnFailure(
        uint256 _id
    ) external onlyTrustedCaller(_id) returns (uint256 requestId) {
        RaffleStruct storage raffle = raffles[_id];

        // Will revert if subscription is not set and funded.
        requestId = i_vrfCoordinator.requestRandomWords(
            i_gasLane,
            i_subscriptionId,
            REQUEST_CONFIRMATIONS,
            i_callbackGasLimit,
            NUM_WORDS
        );
        s_requests[requestId] = RequestStatus({
            randomWords: new uint256[](0),
            exists: true,
            fulfilled: false
        });

        requestIds.push(requestId);
        lastRequestId = requestId;

        // result is the requestId generated by chainlink. It is saved in a map linked to the param id
        chainlinkRaffleInfo[requestId] = RaffleInfo({
            id: _id,
            size: raffle.entriesLength
        });
        emit RequestSent(requestId, NUM_WORDS);
        return requestId;
    }
}
